<!DOCTYPE html>
<html>
  <head>
    <title>hersheytext.js Font Render Example</title>
    <meta charset="UTF-8">
    <script src="https://code.jquery.com/jquery-1.11.1.min.js"></script>
    <style type="text/css">
      body {
        font-family: sans-serif;
        max-width: 640px;
      }

      fieldset {
        background-color: #fff;
      }

      fieldset input, fieldset select {
        margin-bottom: 1em;
        display: block;
        min-width: 200px;
      }

      textarea {
        width: 100%;
        height: 300px;
      }

      #fonttext {
        font-size: 1.25em;
        width: 100%;
      }

      #fontselect {
        height: 8em;
        font-size: 0.75em;
      }

      #main {
        padding: 1em;
      }

      button {
        height: 3em;
        font-size: 1em;
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <fieldset>
      <!-- <legend>Options</legend> -->
      <label for="fonttext">Input text:</label>
      <input id="fonttext" type="text" value="Hello World!">

      <label for="fontselect">Font:</label>
      <select id="fontselect">
        <option id="loading">Loading Fonts...</option>
      </select>
      <button type="button" id="downloadSvgButton">Download SVG</button>
    </fieldset>

    <div id="main" >
      <svg xmlns="http://www.w3.org/2000/svg"
      xmlns:xlink="http://www.w3.org/1999/xlink" width="640" height="280"></svg>
    </div>

    <a id="showRaw" href="">Show raw SVG content</a>
    <div id="rawContent">
      <label class="hidden">Raw SVG content of text</label><br>
      <textarea class="hidden"></textarea>  
    </div>

<script type="text/javascript">

  // Load the font JSON data
  $.getJSON('hersheytext.min.json', function(fonts){

    // Font data is loaded!
    $('#loading').remove();

    // Populate font choices
    for (let id in fonts) {
      $('<option>').text(fonts[id].name).val(id).appendTo('#fontselect');
    }
    $('#fontselect')[0].value= "futural";

    $('#fontselect').change(function() {
      $('#textexample').remove(); // Kill the old one (if any)

      // Render some text into the SVG area with it
      renderText($('#fonttext').val(), {
        font: fonts[$(this).val()],
        pos: {x: 0, y: 0},
        scale: 2,
        charWidth: 8,
        wrapWidth: 70,
        centerWidth: 200,
        target: '#main svg',
        id: 'textexample'
      });

      // REQUIRED: Refresh DOM to reinstate node status with XML namespaces
      // TODO: There must be a better way to do this! :P
      $('#main').html($('#main').html());
      $('textarea').val($('#main svg')[0].outerHTML);
    }).attr('size', 10).change(); // Trigger initial run

    // Re-render on keypress
    $('input').on('input', function(e){
      $('#fontselect').change();
    });

    $('#showRaw').on('click', function(event){
      event.preventDefault();
      $('#showRaw').addClass('hidden');
      $('#rawContent *').removeClass('hidden');
    });
    
    $('#downloadSvgButton').on('click', exportSVG);
  });

  function exportSVG() {
    let string = $('#main svg')[0].outerHTML; // raw svg 
    // console.log(string)
    if (!string) return;
    let blob = new Blob([string], {type: "image/svg+xml;charset=utf-8"});
    let url = window.URL.createObjectURL(blob);
    let a = document.createElement("a");
    a.href = url;
    a.download = truncate($('#fonttext').val().replace(/[^a-z0-9]/gi, '_').toLowerCase(), 100); // download file name
    a.click();
    window.URL.revokeObjectURL(url);
  }

  function truncate(str, n){
    return (str.length > n) ? str.substr(0, n-1) : str;
  };

/**
 * Render a string of text in a Hershey engraving font to a given SVG element
 *
 * @param {string} s
 *   Text string to be rendered
 * @param {object} options
 *   Object of named options:
 *    font {obj}: [Required] Font object containing path elements for font
 *    id {string}: [Required] ID to give the final g(roup) SVG DOM object
 *    pos {object}: [Required] {X, Y} object of where to place the final object within the SVG
 *    charWidth {int}: [Optional] Base width given to each character
 *    charHeight {int}: [Optional] Base height given to each character (when wrapping)
 *    scale {int}: [Optional] Scale to multiply size of everything by
 *    wrapWidth {int}: [Optional] Max line size at which to wrap to the next line
 *    centerWidth {int}: [Optional] Width to center multiline text inside of
 *    centerHeight {int}: [Optional] Height to center text inside of vertically
 *
 * @returns {boolean}
 *   Operates directly on the given target given in options, returns false if
 *   required option missing or other failure.
 */
  function renderText(s, options) {
    try {
      const font = options.font.chars;
      options.charWidth = options.charWidth ? options.charWidth : 10;
      options.charHeight = options.charHeight ? options.charHeight : 28;

      const offset = { left: 0, top: 0 };
      options.scale = options.scale ? options.scale : 1;

      // Create central group
      const $group = $('<g>').attr({
        id: options.id,
        style: 'stroke:#000000; fill:none;',
        transform:
          'scale(' + options.scale + ') ' +
          'translate(' + options.pos.x + ',' + options.pos.y + ')'
      });
      $(options.target).prepend($group);

      // Initial Line container
      let lineCount = 0;
      let $groupLine = $('<g>').attr('id', options.id + '-line-' + lineCount);
      $group.prepend($groupLine);

      // Move through each word
      const words = s.split(' ');
      for(let w in words) {
        const word = words[w];

        // Move through each letter
        for(let i in word) {
          const index = word.charCodeAt(i) - 33;

          // Only print in range chars
          let charOffset = options.charWidth;
          if (font[index]){
            charOffset = font[index].o;

            // Add the char to the DOM
            $groupLine.prepend(
              $('<path>').attr({
                d: font[index].d,
                style: 'stroke:#000000; fill:none;',
                fill: 'none',
                transform: 'translate(' + offset.left + ', ' + offset.top + ')'
              })
            );
          }

          // Add space between
          offset.left+= charOffset + options.charWidth;
        }

        // Wrap words to width
        if (options.wrapWidth) {
           if (offset.left > options.wrapWidth) {
             if (options.centerWidth) {
               const c = (options.centerWidth / 2) - (offset.left / 2);
               $groupLine.attr('transform', 'translate(' + c + ',0)');
             }

             offset.left = 0;
             offset.top += options.charHeight;

             // New Line container
             lineCount++;
             $groupLine = $('<g>').attr('id', options.id + '-line-' + lineCount);
             $group.prepend($groupLine);
           } else {
             offset.left += options.charWidth*2; // Add regular space
           }
         } else {
           offset.left += options.charWidth*2; // Add regular space
         }
       }

      if (options.centerWidth) {
        const c = (options.centerWidth / 2) - (offset.left / 2);
        $groupLine.attr('transform', 'translate(' + c + ',0)');
      }

      if (options.centerHeight) {
        const c = (options.centerHeight / 2) - ((options.charHeight*(lineCount+1)) / 2) + options.pos.y;
        $group.attr({
          transform:
          'scale(' + options.scale + ') ' +
          'translate(' + options.pos.x + ',' + c + ')'
        });
      }
    } catch(e) {
      console.error(e);
      return false; // Error!
    }

    return true; // We should be all good!
  }


</script>

  </body>
</html>
